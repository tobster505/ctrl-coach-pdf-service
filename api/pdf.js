module.exports = async (req, res) => {
  try {
    const name = String((req.query && req.query.name) || 'ctrl_report.pdf')
      .replace(/[^\w.\-]+/g, '_');
    const b64 = String((req.query && req.query.data) || '');
    if (!b64) {
      res.statusCode = 400;
      return res.end('Missing data');
    }

    let payload;
    try {
      payload = JSON.parse(Buffer.from(b64, 'base64').toString('utf8'));
    } catch {
      res.statusCode = 400;
      return res.end('Invalid data');
    }

    const {
      title = 'CTRL — Snapshot',
      intro = '',
      headline = '',
      chartUrl = '',
      how = '',
      journey = '',            // "• ..." lines separated by \n
      themesExplainer = '',    // "• ..." lines separated by \n
      raw = {}
    } = payload || {};

    const PDFDocument = require('pdfkit');
    const doc = new PDFDocument({ size: 'A4', margins: { top: 40, bottom: 40, left: 50, right: 50 } });

    // Basic unicode-safe sanitiser (avoid fancy arrows/quotes that WinAnsi can’t encode)
    const clean = (s) =>
      String(s || '')
        .replace(/[–—]/g, '-')
        .replace(/[“”]/g, '"')
        .replace(/[‘’]/g, "'")
        .replace(/[→←↔↑↓]/g, '->');

    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${name}"`);
    doc.pipe(res);

    doc.font('Helvetica-Bold').fontSize(18).text(clean(title));
    if (intro) {
      doc.moveDown(0.5);
      doc.font('Helvetica').fontSize(11).text(clean(intro));
    }
    if (headline) {
      doc.moveDown();
      doc.font('Helvetica-Bold').fontSize(13).text(clean(headline));
    }

    // Chart image (optional)
    if (chartUrl) {
      try {
        const r = await fetch(chartUrl);
        const ab = await r.arrayBuffer();
        const buf = Buffer.from(ab);
        doc.moveDown(0.5);
        doc.image(buf, { fit: [460, 300], align: 'center' });
      } catch (e) {
        console.error('Chart fetch failed', e);
        doc.moveDown(0.5).font('Helvetica').fontSize(10)
          .fillColor('#aa0000').text('Chart image unavailable.');
        doc.fillColor('black');
      }
    }

    if (how) {
      doc.moveDown();
      doc.font('Helvetica-Bold').fontSize(12).text('How this tends to show up');
      doc.font('Helvetica').fontSize(11).text(clean(how));
    }

    if (journey) {
      doc.moveDown();
      doc.font('Helvetica-Bold').fontSize(12).text('Where the journey points');
      const items = clean(journey).split('\n').map(x => x.replace(/^\s*•\s*/, '')).filter(Boolean);
      doc.font('Helvetica').fontSize(11).list(items);
    }

    if (themesExplainer) {
      doc.moveDown();
      doc.font('Helvetica-Bold').fontSize(12).text('Themes that kept popping up');
      const items = clean(themesExplainer).split('\n').map(x => x.replace(/^\s*•\s*/, '')).filter(Boolean);
      doc.font('Helvetica').fontSize(11).list(items);
    }

    // Raw page
    if (raw && (raw.sequence || raw.counts || raw.perQuestion)) {
      doc.addPage();
      doc.font('Helvetica-Bold').fontSize(12).text('Raw data');
      doc.moveDown(0.25);
      if (raw.sequence) doc.font('Helvetica').fontSize(10).text(`Sequence: ${clean(raw.sequence)}`);
      if (raw.counts) {
        const countsLine = typeof raw.counts === 'string'
          ? raw.counts
          : `C:${raw.counts.C}  T:${raw.counts.T}  R:${raw.counts.R}  L:${raw.counts.L}`;
        doc.text(`Counts: ${countsLine}`);
      }
      if (Array.isArray(raw.perQuestion)) {
        for (const pq of raw.perQuestion) {
          doc.moveDown(0.1);
          doc.text(`Q${pq.q}: ${pq.state} (${pq.stateName || ''})`);
          if (pq.themes && pq.themes.length) doc.text(`Themes: ${pq.themes.join(', ')}`, { indent: 12 });
        }
      }
    }

    doc.moveDown();
    doc.fontSize(8).fillColor('#777').text('CTRL — Generated by /api/pdf');
    doc.end();
  } catch (err) {
    console.error('PDF error', err);
    res.statusCode = 500;
    res.end('Error generating PDF');
  }
};
